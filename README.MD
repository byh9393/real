
________________________________________
1. 프로젝트 개요
1.1 목표
•	Python + Upbit Open API 기반 완전 자동매매 시스템 구축
•	사용자 개입 없이:
o	코인 자동 선별
o	다중 기술적 지표·수학적 팩터 조합
o	복합 전략으로 매수/매도 신호 생성
•	리스크 최소화 & 이익 극대화:
o	수수료·슬리피지·최소 주문금액을 모두 반영한 실매매 수준의 엔진
o	엄격한 리스크 관리(포지션·일손실·변동성 기반 자금배분)
•	사용자 친화적 대시보드:
o	최신 트렌드의 UI (웹 기반 대시보드 권장: React + Tailwind)
o	거래 시작/중지, 전략 상태, 계좌·포지션 조회를 직관적으로 제공
1.2 필수 제약 조건
•	거래소: Upbit KRW 마켓 기준 (필요시 BTC/USDT 마켓도 확장 가능)
•	거래 수수료:
o	KRW 마켓 수수료는 일반적으로 약 0.05% 수준으로 알려져 있으나, 이벤트에 따라 변동 가능 (CoinGecko)
o	실제 적용 수수료는 Upbit /v1/orders/chance 의 bid_fee, ask_fee 필드에서 각 마켓별로 조회해야 함 (Upbit Developer Center)
•	최소 주문금액:
o	Upbit KRW 마켓 최소 주문금액: 5,000 KRW (업비트(UPbit))
o	봇 로직 상 최소 매수금액: 30,000 KRW (사용자 요구사항)
o	실제 주문 시 **실제 최소값 = max(봇 최소 30,000, 거래소 최소 5,000 또는 market.bid.min_total)**로 적용
•	가격 호가단위·틱 사이즈:
o	KRW 마켓은 가격 구간에 따라 호가 단위가 다름. 예: 10,000~50,000원 구간은 10원 단위 등 (업비트 개발자 센터)
o	주문 가격은 반드시 해당 호가 단위에 맞게 반올림·절사 필요
•	API 연동 방식:
o	시세 데이터: REST + WebSocket 둘 다 사용 가능 (업비트 개발자 센터)
o	시세/호가/캔들은 REST 및 WebSocket 시세 API, 주문·잔고는 Exchange API 사용 (업비트 개발자 센터)
________________________________________
2. 전체 시스템 아키텍처
2.1 모듈 구조 개요
1.	API 어댑터 레이어 (UpbitAdapter)
o	REST 클라이언트
o	WebSocket 클라이언트
o	인증(JWT) / Rate Limit 관리
2.	데이터 레이어 (MarketData Service)
o	마켓 리스트 관리 (KRW-XXX)
o	OHLCV 히스토리 수집 & 캐시
o	실시간 틱/체결/호가 스트림 관리
3.	전략 엔진 (Strategy Engine)
o	인디케이터 계산 모듈
o	팩터(수학/통계) 계산 모듈
o	종목별 종합 스코어링 및 진입/청산 신호 생성
o	멀티 전략(트렌드/역추세/브레이크아웃 등) 조합 컨트롤러
4.	리스크 & 포트폴리오 엔진 (Risk & Portfolio Engine)
o	자금 배분 (per-trade, per-asset, portfolio-level)
o	손절·익절·트레일링 스탑·시간 청산
o	일/주/월 손실 제한 및 긴급 스위치
5.	주문 & 체결 엔진 (Execution Engine)
o	주문 생성/취소/수정
o	최소 주문금액·틱 사이즈·수수료 반영한 체결 수량 계산
o	부분 체결/미체결 관리
o	재시도·실패 처리
6.	상태 관리 & 저장소 (State & Storage)
o	DB(예: PostgreSQL 또는 MySQL) 스키마
o	포지션, 주문, 체결, 캔들, 전략 상태, 리스크 이벤트 로그 저장
7.	백테스트 & 리서치 엔진
o	과거 데이터 기반 시뮬레이션
o	파라미터 최적화(그리드/랜덤/베이지안)
o	워크포워드 테스트 및 과최적화 방지 도구
8.	모니터링 & 알림 (Monitoring & Alerting)
o	로그 수집 및 시각화
o	텔레그램/슬랙 알림
o	에러/리스크 이벤트/손실 한도 초과 알림
9.	대시보드 앱
o	Backend: FastAPI(or Flask) + WebSocket
o	Frontend: React + Tailwind (차트: Recharts, ECharts 등)
o	기능: 실시간 계좌/포지션/전략 상태/설정/On-Off 컨트롤
________________________________________
3. Upbit 연동 및 인프라 기능
3.1 인증 & API 키 관리
필수 기능
•	OPEN API 키 발급·저장·로테이션 기능
o	Access Key/Secret Key는 환경변수 또는 암호화된 파일/키 관리 시스템에 저장
o	IP 화이트리스트 등록 절차 반영 (글쓰는 개발자)
•	JWT 토큰 생성 유틸
o	access_key, nonce(UUID), query_hash, query_hash_alg(SHA512) 기반 토큰 생성 (ujhin.github.io)
o	REST 호출 전 공통 미들웨어로 Authorization 헤더 자동 세팅
3.2 REST & WebSocket 클라이언트
REST
•	엔드포인트 래핑:
o	시세: /v1/market/all, /v1/candles/*, /v1/ticker, /v1/trades/ticks (글쓰는 개발자)
o	주문: /v1/orders, /v1/orders/chance, /v1/order(단건 조회), /v1/orders(리스트) (업비트 개발자 센터)
o	잔고: /v1/accounts
•	공통 기능:
o	Rate Limit 헤더 기반 호출 간격 조절 (업비트 개발자 센터)
o	4xx/5xx 에러 리트라이 정책
o	Gzip 압축 대응
WebSocket
•	실시간 데이터 수신:
o	체결, 호가창, 현재가 스트림
o	나의 주문/체결 스트림 (실시간 포지션 업데이트) (Upbit Developer Center)
•	재연결 전략:
o	네트워크 오류/핑 타임아웃 시 재접속
o	재접속 시 마지막 시점 이후 주문·체결은 REST로 재동기화
________________________________________
4. 마켓 데이터 & 유니버스 관리
4.1 거래 가능 마켓 유니버스 정의
필수 기능
•	/v1/market/all 호출로 전체 마켓 리스트 수집 (글쓰는 개발자)
•	KRW-마켓만 필터링 (예: market.startswith("KRW-"))
•	아래 조건으로 유니버스 필터:
o	최근 30일 평균 일 거래대금 ≥ X억 KRW
o	상장 폐지 예정, 유의 종목, 유동성 부족 종목 제외 (필요시 Upbit 공지 API or 별도 데이터 사용)
o	스프레드(호가 1~2단) 비정상 큰 종목 제외
•	유니버스 동적 갱신:
o	하루 1회 이상 유동성 재평가
o	과거 24시간 거래대금 기준으로 상위 N개 코인만 매매
4.2 OHLCV 데이터 수집 & 캐시
해상도
•	최소: 1분/3분/5분/15분/60분/일봉
•	전략에서 사용하는 대표 타임프레임:
o	단기 진입: 1m~5m
o	추세 확인: 30m~4h
o	상위 추세 필터: 1d
필수 기능
•	일정 간격(예: 1~5분)에 OHLCV 업데이트
•	과거 N일(예: 180~365일) 데이터 로컬 DB에 저장
•	데이터 품질 체크:
o	누락 캔들/비정상 스파이크 검출
o	시계열 연속성 검증
________________________________________
5. 전략 엔진 – 수학적·기술적 복합 전략 설계
5.1 멀티 타임프레임 구조
필수 기능
•	각 코인에 대해 다음 타임프레임 동시 계산:
o	짧은 추세: 5m, 15m
o	중기 추세: 1h, 4h
o	장기 레짐: 1d
•	타임프레임간 동기화:
o	“신호 발생 기준 시점”에서 상위 타임프레임의 상태(예: 1h, 4h 추세 방향)를 함께 참조
5.2 기술적 지표 세트
라이브 코어엔 꼭 필요하고, 백테스트에도 동일하게 적용해야 하는 지표들:
1.	추세 지표
o	EMA/SMA (단기·중기·장기, 예: 9/21/50/200)
o	MACD (12,26,9)
o	ADX (추세 강도 필터)
2.	모멘텀 지표
o	RSI (14, 7 등 복수 기간)
o	Stochastic (K,D)
o	ROC(수익률), Cumulative Returns
3.	변동성 지표
o	ATR (Average True Range)
o	볼린저 밴드 (20일 중심, 상·하단)
o	Realized Volatility (σ of log returns)
4.	거래량·수급 지표
o	VWAP (거래대금 가중 평균가)
o	OBV, Volume Spike(직전 n기간 대비 급증)
o	Volume-Price Trend
5.	시장 레짐·상관성 지표
o	BTC/KRW, ETH/KRW와의 상관계수
o	전체 시장 변동성 지수(내부 산출, 예: 상위 N개 종목 평균 변동성)
o	Hurst Exponent 또는 단순 regime classifier (트렌드형 vs 박스형)
5.3 팩터 기반 스코어링
각 코인에 대해 “종합 점수”를 계산하는 팩터 엔진:
•	예시 팩터:
o	Trend Factor: (단기 EMA > 중기 EMA > 장기 EMA 여부, ADX>임계값 여부)
o	Momentum Factor: (1h·4h·1d 수익률, RSI 50~70 구간 등)
o	Volatility Factor: ATR/Price (너무 낮거나 너무 높은 변동성 제거)
o	Volume Factor: 최근 거래대금/평균 거래대금 비율
o	Correlation Factor: BTC와의 상관성 (과도한 동행 종목 제거나 반대로 활용)
필수 기능
•	각 팩터를 0~1 혹은 -1~1 스코어로 정규화
•	종합 스코어:
[
Score = w_T \cdot Trend + w_M \cdot Momentum + w_V \cdot Volatility + w_Q \cdot Volume + ...
]
•	Threshold 기반 진입 조건:
o	Score > Long_Threshold → 롱 진입
o	Score < Exit_Threshold → 청산 혹은 진입 회피
5.4 진입 전략(롱 전용, 무차입 기준)
예시 구조 (변형 가능):
1.	기본 진입 조건
o	상위 타임프레임(1h/4h) 상승 추세 (EMA, MACD > 0)
o	단기 타임프레임(5m/15m)에서 조정 후 반등 신호:
	가격이 20EMA 아래로 살짝 이탈 후 다시 돌파
	RSI가 과매도 구간(30 미만) 터치 후 30~50 사이로 복귀
2.	변동성/수수료 필터
o	목표 수익률이 최소 2 * (수수료 + 예상 슬리피지) 이상 확보되는 구간만 진입
o	ATR 기준 최소 이동폭(예: 1.5~2 ATR) 이상을 목표로 하지 않으면 진입 금지
3.	유니버스 필터와의 결합
o	거래대금 상위 N개, 스프레드가 얇은 코인만 대상으로
o	하루당 종목당 진입 횟수 제한(예: 3회)
5.5 청산 전략
필수 기능
1.	정적 손절 (Hard Stop-Loss)
o	진입가 기준 -X% (예: -1.5%~-3%) 또는
o	ATR 기반 손절: 진입가 - k * ATR (예: 1.5 ATR)
2.	다단계 익절·트레일링 스탑
o	1차 목표: +2% 도달 시 일부(예: 50%) 익절 + 나머지 물량에 트레일링 스탑 (예: 고점 대비 -1 ATR)
o	2차 목표: +4~6% 이상에서 추가 익절 혹은 트레일링 강화
o	급등 시 상한 근처(예: 1시간 내 급등 후 RSI>80 & 볼륨 급증)에서 보호 매도
3.	시간 기반 청산(Time-based Exit)
o	진입 후 N 봉(예: 60분, 4시간 등) 동안 목표 수익 미달·추세 전환 시 청산
o	과도한 횡보 포지션 제거로 자금 회전율 유지
5.6 포트폴리오·자금 배분 전략
필수 기능
•	1회 진입당 최소 주문 금액: 30,000 KRW 이상
o	실제 주문 계산 시:
	order_capital = max(user_config_min(=30000), upbit_min_total(market.bid.min_total)) (ujhin.github.io)
•	계좌 총액의 % 기반 자금배분:
o	예: 총자산의 2%를 1회 트레이드 위험으로 설정
•	ATR 기반 포지션 사이징:
[
position_size = \frac{risk_per_trade}{stop_distance}
]
•	종목당 최대 비중, 전체 오픈 포지션 수 제한
•	높은 상관성 종목끼리는 동시 진입 제한 (예: 동일 섹터, BTC와 강한 동행성 등)
________________________________________
6. 주문 & 체결 엔진 (Execution Engine)
6.1 주문 전 검증 로직
필수 체크 항목
1.	최소/최대 주문 금액
o	orders/chance로 각 마켓의 bid.min_total, ask.min_total, max_total 조회 후 검증 (ujhin.github.io)
o	봇 내부 최소(30,000원)와 교차 검증
2.	수수료 반영
o	bid_fee, ask_fee로 체결 예상 수수료 계산
o	진입 전 예상 손익(수수료 포함) > 0 인지 확인
3.	호가 단위 정합성
o	가격을 해당 구간의 호가 단위로 반올림/내림 (예: round(price / tick) * tick) (업비트 개발자 센터)
4.	수량 소수점 처리
o	KRW 마켓 수량은 대개 소수점 8자리까지 허용
o	최소 주문 수량 = min_total / price 로 계산 후 이상 여부 확인 (igotit)
6.2 주문 타입 전략
•	시장가 주문
o	빠른 체결이 중요할 때 사용
o	슬리피지 상한(예: 기대 체결가 대비 ±0.3% 이상이면 거부) 체크
•	지정가 주문
o	호가 1~2단 안쪽에 “유리한 가격”으로 제출
o	시간 경과/체결율 낮을 경우 시장가 변환 또는 가격 조정
•	향후:
o	예약 주문(Upbit 예약 주문 기능은 웹 UI 중심이므로, API로는 자체 트리거 로직 구현)
6.3 주문 상태 관리
필수 기능
•	주문 객체(Order Model):
o	uuid, 시장, 방향(bid/ask), 타입(limit/market), 가격, 수량, 상태(wait/partial/done/canceled)
•	상태 전이:
o	주문 제출 → 대기(wait) → 부분 체결(partial) → 전량 체결(done) or 취소(canceled)
•	재시도 로직:
o	네트워크 에러 / 429 Rate Limit → exponential backoff 후 재시도
o	부분 체결 장기 지속 → 잔량 시장가 정리 옵션
________________________________________
7. 리스크 & 자금 관리
7.1 계좌 레벨 리스크
필수 기능
•	일일 손실 한도 (예: -3% 또는 -X 만원 손실 시 당일 더 이상 신규 진입 금지)
•	최대 드로우다운 관리:
o	최근 30일/90일 최고 자산 대비 MDD가 특정 값 이상이면 전략 중단
•	전체 익스포저 한도:
o	전체 포지션 합계가 계좌의 Y% 이상 넘어가지 않도록 제한
7.2 트레이드 레벨 리스크
•	per-trade 손실 한도:
o	진입 시점에 stop-loss까지 손실이 계좌의 Z%를 넘지 않도록 포지션 크기 조정
•	코인당 중복 진입 제한:
o	동일 코인에 동시 N개 이상 포지션 금지
•	고변동성 이벤트(뉴스, 상장폐지, 급등락) 감지 시 일시 거래 중단
________________________________________
8. 백테스트 & 리서치 엔진
8.1 백테스트 프레임워크 요구사항
필수 기능
•	Upbit OHLCV 데이터 사용
•	수수료·슬리피지·최소 주문금액·호가 단위 반영
•	여러 종목 동시 시뮬레이션 (포트폴리오 단위)
•	지표·전략 로직이 라이브 코드와 100% 동일하게 동작해야 함 (코드 공유 구조)
백테스트의 중요성은 다양한 자료에서 강조되고 있으며, 실전 투입 전 전략 가설 검증의 핵심 도구로 언급된다. (OKX)
8.2 성능 지표
•	수익률 관련:
o	총/연율화 수익률, 일별·월별 수익률
o	승률, 평균 이익/손실, Profit Factor
•	리스크 관련:
o	최대 손실(MDD)
o	Sharpe Ratio, Sortino Ratio
o	손익비(R:R), 연속 손실 횟수
•	실행 관련:
o	평균 슬리피지
o	평균 보유 기간
o	거래 빈도
8.3 최적화 & 검증
•	파라미터 탐색:
o	단순 그리드/랜덤 서치 + Optuna 같은 베이지안 최적화 도구 사용 가능 (Token Metrics)
•	워크포워드 테스트:
o	학습 기간·검증 기간을 분리해 과최적화 방지
•	리샘플링·몬테카를로:
o	트레이드 순서 랜덤화, 부트스트랩 등으로 전략 안정성 확인
________________________________________
9. 대시보드 앱 설계
9.1 아키텍처
•	Backend
o	FastAPI (Python)
o	DB 연동 (포지션, 주문, 전략 상태, 로그)
o	REST + WebSocket:
	REST: 계좌 조회, 과거 데이터, 설정 변경
	WebSocket: 실시간 PnL, 포지션, 알림 스트림
•	Frontend
o	React + Vite/Next.js + Tailwind CSS
o	차트 라이브러리: Recharts, ApexCharts, ECharts 등
o	JWT 기반 로그인 인증 (Admin/Read-only 권한 분리)
9.2 주요 화면 및 기능
1.	메인 대시보드
o	현재 총 자산, 사용 가능 현금, 평가손익, 일일 실현손익
o	실시간 에쿼티 곡선(누적 PnL)
o	전략 전체 ON/OFF 버튼
o	“긴급 ALL STOP” 버튼 (신규 진입 중단 + 기존 포지션 유지/청산 옵션 선택)
2.	포지션 & 주문 화면
o	보유 코인 리스트:
	종목, 보유 수량, 평균 매입가, 현재가, 평가손익(%, 금액), 설정된 손절·익절·트레일링 레벨
o	진행 중인 주문 리스트:
	주문 타입, 남은 수량, 체결 비율, 경과 시간
o	체결 히스토리:
	각 트레이드별 인/아웃, 수익/손실, 지표 상태 스냅샷
3.	전략 모니터링 화면
o	코인별 스코어(Trend/Momentum/Volume 등)를 시각화한 Heatmap
o	각 코인 차트(캔들 + 지표 + 매수/매도 마커)
o	전략별 ON/OFF (예: Trend 전략, Mean-Reversion 전략 개별 스위치)
4.	설정 화면
o	리스크 파라미터:
	1회 트레이드 위험 %, 일일 손실 한도, 코인당 최대 비중 등
o	전략 파라미터:
	각 지표 기간, 스코어 가중치, 진입/청산 기준
o	시스템 설정:
	로그 레벨, 알림 채널(텔레그램, 슬랙) 토글
o	설정 변경시:
	“적용 전 미리보기” + “재시작 필요 여부” 안내
5.	로그 & 알림 화면
o	최근 이벤트 타임라인:
	“BTC 급락 감지로 신규 진입 중단”, “일일 손실 한도 도달” 등
o	에러 로그:
	API 에러, 재연결 여부, 백오프 내역
9.3 디자인 가이드
•	다크 테마 + 카드형 레이아웃
•	중요 지표는 한 눈에:
o	PnL, 손실 한도, 전략 상태, API 연결 상태
•	반응형 UI:
o	데스크톱 중심, 태블릿도 고려
•	사용자 실수 방지:
o	긴급 정지/전략 비활성화에는 두 번의 확인 팝업
o	설정 변경 시 영향 범위 명시
________________________________________
10. DB 스키마 & 상태 복구
10.1 핵심 테이블
•	accounts_snapshot : 시간별 잔고/평가액 스냅샷
•	positions : 현재 포지션
•	orders : 주문 상태 기록
•	trades : 체결 내역
•	candles : OHLCV 히스토리
•	strategy_state : 전략별 파라미터/상태
•	risk_events : 리스크 트리거(일손실 초과 등)
•	config_history : 설정 변경 이력
10.2 재시작/복구 로직
•	시스템 재시작 시:
o	Upbit /v1/accounts, /v1/orders 를 조회해 실제 계좌 상태와 DB 동기화 (글쓰는 개발자)
o	DB에 기록된 포지션과 불일치 시, Upbit 기준으로 포지션 재구성
•	중복 주문 방지:
o	identifier 필드를 사용해 같은 주문이 두 번 발행되지 않도록 제어 (ujhin.github.io)
________________________________________
11. 비기능 요구사항
•	성능
o	전체 유니버스(예: 최대 50~100개) 기준 1초 내 신호·리스크 평가 가능
o	WebSocket 기반 실시간 업데이트 지연 최소화
•	안정성
o	API 5xx, 네트워크 단절에 대한 회복력
o	예외 처리 미비로 인한 봇 종료 방지(프로세스 감시, Supervisor/Docker 재시작)
•	보안
o	API Key 암호화 저장
o	대시보드 접근 권한 제어, HTTPS 적용
•	테스트
o	모듈 단위 테스트 (전략 로직, 주문 계산, 리스크 엔진)
o	통합 테스트 (모의 계좌 + 샌드박스/리플레이 모드)
________________________________________
12. 개발 로드맵 (요약)
1.	1단계 – 인프라 & API 래퍼
o	Upbit REST/WebSocket 어댑터
o	기본 계좌 조회/단일 코인 매수·매도 성공까지
2.	2단계 – 데이터 & 백테스트 엔진
o	OHLCV 수집·저장
o	단일 전략 백테스트 + 수수료·최소 주문금액 반영
3.	3단계 – 전략 & 리스크 엔진
o	멀티 타임프레임·지표·팩터 기반 스코어링
o	포지션/리스크 관리 로직 완성
4.	4단계 – 라이브 트레이딩 코어
o	이벤트 루프 + 실시간 주문/체결 연동
o	일 손실 한도·긴급 스위치 탑재
5.	5단계 – 대시보드
o	Web API + React 대시보드 MVP
o	계좌·포지션·히스토리·컨트롤 UI 구현
6.	6단계 – 고도화
o	전략 파라미터 자동 최적화
o	추가 전략(역추세, 브레이크아웃 등) 플러그인화
o	ML/AI 기반 시그널(원하면 추가)
________________________________________

